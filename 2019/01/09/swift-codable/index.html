<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Swift Codable深度实践 | anthann&#39;s personal blog</title>

  
  <meta name="author" content="anthann">
  

  
  <meta name="description" content="Codable前世Swift 4为我们带来了新的协议–Codable，遵循此协议的实例可以在集中不同的类型之间转换（JSON、Proterty List、二进制等）。  
从Objective-C转过来的开发者一定很熟悉另一个协议–NSCoding，这个协议存在于Foundation框架内，作用是让">
  

  
  
  <meta name="keywords" content="">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Swift Codable深度实践">

  <meta property="og:site_name" content="anthann&#39;s personal blog">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="anthann&#39;s personal blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">anthann&#39;s personal blog</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Swift Codable深度实践</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/01/09/swift-codable/" rel="bookmark">
        <time class="entry-date published" datetime="2019-01-09T12:25:16.000Z">
          2019-01-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Codable前世"><a href="#Codable前世" class="headerlink" title="Codable前世"></a>Codable前世</h2><p>Swift 4为我们带来了新的协议–<code>Codable</code>，遵循此协议的实例可以在集中不同的类型之间转换（JSON、Proterty List、二进制等）。  </p>
<p>从Objective-C转过来的开发者一定很熟悉另一个协议–<code>NSCoding</code>，这个协议存在于<code>Foundation</code>框架内，作用是让遵循此协议的对象可以转换成二进制格式。既然已经有<code>NSCoding</code>，为何还要新出一个<code>Codable</code>呢？我自己的理解，大概是以下几个原因：  </p>
<ol>
<li><code>Codable</code>是Swift语言的一部分，不需要<code>Foundation</code>。</li>
<li><code>NSCoding</code>只支持继承自NSObject的Class，而<code>Codable</code>可以支持原始类型、Struct、Enum、Class等多种类型。  </li>
<li>相当多情况下，只需要在类型声明时加上<code>Codable</code>关键字，类型就直接具备了Codable能力，不需要多写一行代码！  </li>
<li><code>NSCoding</code>只能让对象在内存实例和二进制格式之间互相转换，而<code>Codable</code>还支持了JSON、Proterty List等其他不同的格式。用了<code>Codable</code>之后甚至也可以不再用<code>ObjectMapper</code>等第三方库（这部分不展开讨论）。  </li>
</ol>
<h2 id="Codable今生"><a href="#Codable今生" class="headerlink" title="Codable今生"></a>Codable今生</h2><p>那么Codable这个协议到底是什么样子的？首先上定义：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Codable</span> = <span class="type">Decodable</span> &amp; <span class="type">Encodable</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Encodable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Decodable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Codable</code>本质是打包了<code>Decodable</code>和<code>Encodable</code>两个协议，这两个协议分别定义了一个方法。整体看上去非常简洁。  </p>
<p>很多时候，我们也许只需要用到Encode或Decode，那么只需要实现相应的协议即可。  </p>
<h2 id="上手实践"><a href="#上手实践" class="headerlink" title="上手实践"></a>上手实践</h2><h4 id="0x01-基本用法"><a href="#0x01-基本用法" class="headerlink" title="0x01 基本用法"></a>0x01 基本用法</h4><p>从一个简单的例子来说明<code>Codable</code>到底怎么用。  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="type">Animal</span>(name: <span class="string">"旺财"</span>, age: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用JSONEncoder把animal实例编码成JSON Data</span></span><br><span class="line"><span class="keyword">let</span> jsonEncoder = <span class="type">JSONEncoder</span>()</span><br><span class="line"><span class="keyword">let</span> jsonData = <span class="keyword">try</span> jsonEncoder.encode(animal)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> str = <span class="type">String</span>(data: jsonData, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(str)</span><br><span class="line">    <span class="comment">// &#123;"name":"旺财","age":1&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用JSONDecoder把JSON Data解码回instance</span></span><br><span class="line"><span class="keyword">let</span> jsonDecoder = <span class="type">JSONDecoder</span>()</span><br><span class="line"><span class="keyword">let</span> decodedAnimal = <span class="keyword">try</span> jsonDecoder.decode(<span class="type">Animal</span>.<span class="keyword">self</span>, from: jsonData)</span><br></pre></td></tr></table></figure>
<p>可以看到，我们定义了一个类型struct Animal，同时声明这个类型遵循<code>Codable</code>协议。然后创建了一个实例animal，用<code>JSONEncoder</code>直接将其编码成了JSON Data。</p>
<p>struct Animal的定义中没有一行多余的跟<code>Codable</code>相关的代码，为什么就获得了编解码能力呢？因为当定义一个新的类型，其中的所有成员变量的类型都支持<code>Codable</code>协议，那么只要这个新类型声明<code>Codable</code>就直接获得了<code>Codable</code>能力。Swift默认给Int、Double、Bool、Float、String等基本类型提供了<code>Codable</code>支持。  </p>
<h4 id="0x02-手动实现Codable协议"><a href="#0x02-手动实现Codable协议" class="headerlink" title="0x02  手动实现Codable协议"></a>0x02  手动实现Codable协议</h4><p>这一节介绍如何手动实现<code>Codable</code>协议。先上一个稍微复杂的Demo。  </p>
<p>首先，定义Person类型如下，其中的gender字段是Optional<gender>类型，birthday字段是<code>yyyy-MM-dd</code>格式的字符串。</gender></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Gender</span>: <span class="title">Int</span>, <span class="title">Codable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> male = <span class="number">0</span>, female</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> gender: <span class="type">Gender</span>?</span><br><span class="line">    <span class="keyword">let</span> birthday: <span class="type">String</span> <span class="comment">// Format of yyyy-MM-dd</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, gender: <span class="type">Gender</span>?, birthday: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.gender = gender</span><br><span class="line">        <span class="keyword">self</span>.birthday = birthday</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">birthdayFormatter</span><span class="params">()</span></span> -&gt; <span class="type">DateFormatter</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> formatter = <span class="type">DateFormatter</span>()</span><br><span class="line">        formatter.dateFormat = <span class="string">"yyyy-MM-dd"</span></span><br><span class="line">        <span class="keyword">return</span> formatter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，给Person类型实现自定义的<code>Codable</code>协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> name</span><br><span class="line">        <span class="keyword">case</span> gender</span><br><span class="line">        <span class="keyword">case</span> birthday = <span class="string">"timestamp_birthday"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> container = encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">try</span> container.encode(name, forKey: .name)</span><br><span class="line">        <span class="keyword">try</span> container.encodeIfPresent(gender, forKey: .gender)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> timestamp: <span class="type">TimeInterval</span> = <span class="type">Person</span>.birthdayFormatter().date(from: birthday)?.timeIntervalSince1970 <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"invalid birthday"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> container.encode(timestamp, forKey: .birthday)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container = <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        name = <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .name)</span><br><span class="line">        gender = <span class="keyword">try</span> container.decodeIfPresent(<span class="type">Gender</span>.<span class="keyword">self</span>, forKey: .gender)</span><br><span class="line">        <span class="keyword">let</span> timestamp: <span class="type">TimeInterval</span> = <span class="keyword">try</span> container.decode(<span class="type">TimeInterval</span>.<span class="keyword">self</span>, forKey: .birthday)</span><br><span class="line">        birthday = <span class="type">Person</span>.birthdayFormatter().string(from: <span class="type">Date</span>(timeIntervalSince1970: timestamp))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了实现<code>Codable</code>协议，编写了三部分代码：  </p>
<ol>
<li><code>enum CodingKeys: String, CodingKey</code>，定义了一个enum并遵循<code>CodingKey</code>。只有遵循<code>CodingKey</code>协议的类型才可被用做编解码时的Key。   </li>
<li><code>Decodable</code>协议中的<code>init(from:)</code>，初始化方法，把二进制数据解码成内存Instance。</li>
<li><code>Encodable</code>中的<code>encode(to:)</code>，编码方法，把Instance编码城二进制数据。  </li>
</ol>
<p>首先看<code>init(from:)</code>方法。一进来通过调用<code>decoder.container(keyedBy: CodingKeys.self)</code>拿到一个container，有了这个container，我们就可以根据每个key依次取value出来。取value使用<code>decode(_:forKey:)</code>或者<code>decodeIfPresent(_:forKey:)</code>，后者用于optional类型的成员变量。  </p>
<p>再看<code>encode(to:)</code>。同样的，先用<code>encoder.container(keyedBy: CodingKeys.self)</code>拿到一个container，然后调用container的<code>encode(_:forKey:)</code>或<code>encodeIfPresent(_:forKey:)</code>将各个成员变量依次编码。  </p>
<p>以上Demo里，我们使用Key-Value的方式对成员变量进行编解码，用到Keyed Container。Swift也提供了其他的编码方式，相应的有其他Container，例如<code>unkeyedContainer</code>、<code>singleValueContainer</code>等。  </p>
<p>Demo中，成员变量birthday的类型是String，用<code>yyyy-MM-dd</code>的格式表示日期。在编码前，我们手动把birthday转换成了时间戳，实际编码进二进制的也是时间戳。这里想表达的是，很多情况下编码前后的值不是相同的类型/格式，可以通过手动实现编解码方法来做转换。常见的应用场景是服务端返回的json数据以时间戳的形式表示时间，客户端拿到时间戳之后根据时区等信息把时间戳转换成用户可以理解的字符串格式。  </p>
<p>最后是测试代码，与上一个例子类似：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ming = <span class="type">Person</span>(name: <span class="string">"小明"</span>, gender: .male, birthday: <span class="string">"1999-02-11"</span>)</span><br><span class="line"><span class="keyword">let</span> jsonData = <span class="keyword">try</span> <span class="type">JSONEncoder</span>().encode(ming)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> str = <span class="type">String</span>(data: jsonData, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(str)</span><br><span class="line">    <span class="comment">// &#123;"name":"小明","timestamp_birthday":918662400,"gender":0&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用JSONDecoder把JSON Data转回instance</span></span><br><span class="line"><span class="keyword">let</span> decodedMing = <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode(<span class="type">Person</span>.<span class="keyword">self</span>, from: jsonData)</span><br></pre></td></tr></table></figure>
<p>总结一下可能需要手动实现<code>Codable</code>协议的场景：  </p>
<ol>
<li><code>Codable</code>默认把每个成员变量都进行编码。有时候我们可以只编解码部分字段，或者想编解码额外的字段。  </li>
<li>对于同一个字段，编码前后需要用到不同的字段名称，如服务端API返回字段<code>unit_price</code>，客户端对应的是<code>unitPrice</code>。  </li>
<li>对于同一个字段，编码前后需要使用不同的格式/类型，如时间戳和格式化的时间字符串。  </li>
</ol>
<h4 id="0x03-继承"><a href="#0x03-继承" class="headerlink" title="0x03  继承"></a>0x03  继承</h4><p>以上的例子都是定义了struct类型，swift的struct和class之间有许多区别，一个非常大的区别是只有class才支持继承！对于有继承的情况，应该如何使用<code>Codable</code>呢？  </p>
<p>首先定义一个父类Creature，来表示生物。这个父类使用了默认的<code>Codable</code>实现。  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creature</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后定义两个子类Animal和Plant，继承自Creature。因为子类里增加了成员变量，所以实现了自定义的<code>Codable</code>协议。自定义的encode和decode方法需要调用父类的实现。如下所示：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>: <span class="title">Creature</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hasLeg: <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>, hasLeg: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.hasLeg = hasLeg</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container = <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        hasLeg = <span class="keyword">try</span> container.decode(<span class="type">Bool</span>.<span class="keyword">self</span>, forKey: .hasLeg)</span><br><span class="line">        <span class="comment">// 注意：调用父类的init(from:)方法</span></span><br><span class="line">        <span class="keyword">let</span> superDecoder = <span class="keyword">try</span> container.superDecoder()</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">super</span>.<span class="keyword">init</span>(from: superDecoder)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> container = encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">try</span> container.encode(hasLeg, forKey: .hasLeg)</span><br><span class="line">        <span class="comment">// 注意：调用父类的encode(to:)方法</span></span><br><span class="line">        <span class="keyword">let</span> superdecoder = container.superEncoder()</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">super</span>.encode(to: superdecoder)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> hasLeg</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plant</span>: <span class="title">Creature</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>, height: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.height = height</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container = <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        height = <span class="keyword">try</span> container.decode(<span class="type">Double</span>.<span class="keyword">self</span>, forKey: .height)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">let</span> superDecoder = <span class="keyword">try</span> container.superDecoder()</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">super</span>.<span class="keyword">init</span>(from: superDecoder)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> container = encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">try</span> container.encode(height, forKey: .height)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> superdecoder = container.superEncoder()</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">super</span>.encode(to: superdecoder)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证一下，首先编解码父类Creature:  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> creature = <span class="type">Creature</span>(name: <span class="string">"some_name"</span>, age: <span class="number">12</span>)</span><br><span class="line"><span class="keyword">let</span> creatureJsonData = <span class="keyword">try</span> <span class="type">JSONEncoder</span>().encode(creature)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> str = <span class="type">String</span>(data: creatureJsonData, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(str)</span><br><span class="line">    <span class="comment">// &#123;"name":"some_name","age":12&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> decodedCreature: <span class="type">Creature</span> = <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode(<span class="type">Creature</span>.<span class="keyword">self</span>, from: creatureJsonData)</span><br></pre></td></tr></table></figure>
<p>然后再验证编解码子类Animal:  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = <span class="type">Animal</span>(name: <span class="string">"miaomiao"</span>, age: <span class="number">2</span>, hasLeg: <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">let</span> animalJsonData = <span class="keyword">try</span> <span class="type">JSONEncoder</span>().encode(animal)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> str = <span class="type">String</span>(data: animalJsonData, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(str)</span><br><span class="line">    <span class="comment">// &#123;"super":&#123;"name":"miaomiao","age":2&#125;,"hasLeg":true&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> decodedAnimal: <span class="type">Animal</span> = <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode(<span class="type">Animal</span>.<span class="keyword">self</span>, from: animalJsonData)</span><br></pre></td></tr></table></figure>
<p>注意子类Animal编码后的json格式，属于父类的成员变量单独编码成了<code>&quot;super&quot;:{&quot;name&quot;:&quot;miaomiao&quot;,&quot;age&quot;:2}</code>。  </p>
<p>到这里一切都还很美好。</p>
<h4 id="0x04-多态"><a href="#0x04-多态" class="headerlink" title="0x04   多态"></a>0x04   多态</h4><p>面向对象编程，很重要的一个思想是“多态”。我们来试试多态场景下<code>Codable</code>表现的怎么样。</p>
<p>先来把上一节验证编解码子类<code>Animal</code>的代码改成下面这样：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先定义一个Creature类型的对象，并且用子类Animal初始化</span></span><br><span class="line"><span class="keyword">let</span> creature: <span class="type">Creature</span> = <span class="type">Animal</span>(name: <span class="string">"miaomiao"</span>, age: <span class="number">2</span>, hasLeg: <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">let</span> creatureJsonData = <span class="keyword">try</span> <span class="type">JSONEncoder</span>().encode(creature)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> str = <span class="type">String</span>(data: creatureJsonData, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(str)</span><br><span class="line">    <span class="comment">// 这里打印出了以下信息，符合预期 </span></span><br><span class="line">    <span class="comment">//&#123;"super":&#123;"name":"miaomiao","age":2&#125;,"hasLeg":true&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用JSONDecoder把JSON Data转回instance</span></span><br><span class="line"><span class="comment">// 以下这句代码报错了！</span></span><br><span class="line"><span class="keyword">let</span> decodedAnimal: <span class="type">Creature</span> = <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode(<span class="type">Creature</span>.<span class="keyword">self</span>, from: creatureJsonData)</span><br></pre></td></tr></table></figure>
<p>执行一下，最后这句报错了：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▿ DecodingError</span><br><span class="line">  ▿ keyNotFound : 2 elements</span><br><span class="line">    - .0 : CodingKeys(stringValue: &quot;name&quot;, intValue: nil)</span><br><span class="line">    ▿ .1 : Context</span><br><span class="line">      - codingPath : 0 elements</span><br><span class="line">      - debugDescription : &quot;No value associated with key CodingKeys(stringValue: \&quot;name\&quot;, intValue: nil) (\&quot;name\&quot;).&quot;</span><br><span class="line">      - underlyingError : nil</span><br></pre></td></tr></table></figure>
<p>为什么报错了呢？<br>因为<code>try JSONDecoder().decode(Creature.self, from: creatureJsonData)</code>这个decode方法的第一个参数是<code>Creature.self</code>，因此期望第二个参数的内容的形式是<code>{&quot;name&quot;:&quot;miaomiao&quot;,&quot;age&quot;:2}</code>，而不是我们提供的<code>{&quot;super&quot;:{&quot;name&quot;:&quot;miaomiao&quot;,&quot;age&quot;:2},&quot;hasLeg&quot;:true}</code>！  </p>
<p>显然，多态的思想在这里不Work了。怎么办呢？  </p>
<p>面向对象编程时，对象的类型信息在编译或运行时会记录在内存里。举例来说，<code>Objective-C</code>是一门动态语言，运行时每个对象有<code>isa</code>指针，通过这个指针就可以读取到类型信息。再举个例子，C语言里定义一个指向int的指针<code>int *</code>，这个指针本质其实是一个数据结构，这个数据结构里不但存储了指向的地址，同时也要说明指向的地址里存储的是一个int类型的数据。  </p>
<p>说到这里我们应该可以想到解决方法了：<strong>encode时，把对象的类型信息一并编码进去；decode时，先把类型信息拿出来，然后再解码成对应类型的对象</strong>。  </p>
<p>照着这个思路做，就可以解决多态的问题。只不过，写起来很麻烦。后来我从<a href="https://stackoverflow.com/questions/44441223/encode-decode-array-of-types-conforming-to-protocol-with-jsonencoder" target="_blank" rel="noopener">StackOverflow</a>发现了一个优雅的解决方案：  </p>
<p>先说结论：  </p>
<ol>
<li>对每个类簇，实现一个遵守<code>Meta</code>协议的Enum。使用这个Enum可以根据输入的Class Type String获得对应的Type Class。  </li>
<li>编解码类簇里的任意对象，先用<code>MetaObject</code>这个Wrapper包装对象，然后对Wrapper对象编解码。</li>
<li>编解码类簇的Array，先用<code>MetaArray</code>这个Wrapper包装Array，然后对Wrapper对象编解码。  </li>
</ol>
<p>以下是具体的实现方法:  </p>
<h5 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h5><hr>
<p>首先定义一个Protocol：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift无法使用type string来构造Type，因此对每个使用了多态的类簇，实现一个遵守此协议的enum，间接获取Type。</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Meta</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">metatype</span><span class="params">(<span class="keyword">for</span> typeString: String)</span></span> -&gt; <span class="type">Self</span></span><br><span class="line">    <span class="keyword">var</span> type: <span class="type">Decodable</span>.<span class="type">Type</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后定义一个wrapper，这个Wrapper是一个泛型，它实现了Codable:  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MetaObject</span>&lt;<span class="title">M</span>: <span class="title">Meta</span>&gt;: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> object: <span class="type">M</span>.<span class="type">Element</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> object: <span class="type">M</span>.<span class="type">Element</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.object = object</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> metatype</span><br><span class="line">        <span class="keyword">case</span> object</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container = <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="comment">// 首先取出类型信息</span></span><br><span class="line">        <span class="keyword">let</span> typeStr = <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .metatype)</span><br><span class="line">        <span class="comment">// 然后通过类型信息获得Type</span></span><br><span class="line">        <span class="keyword">let</span> metatype = <span class="type">M</span>.metatype(<span class="keyword">for</span>: typeStr)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> superDecoder = <span class="keyword">try</span> container.superDecoder(forKey: .object)</span><br><span class="line">        <span class="comment">// 根据Type调用相对应的类型的init(from:)方法</span></span><br><span class="line">        <span class="keyword">let</span> obj = <span class="keyword">try</span> metatype.type.<span class="keyword">init</span>(from: superDecoder)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> element = obj <span class="keyword">as</span>? <span class="type">M</span>.<span class="type">Element</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.object = element</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> container = encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="comment">// 这里编码了type信息</span></span><br><span class="line">        <span class="keyword">let</span> typeStr = <span class="type">String</span>(describing: type(of: object))</span><br><span class="line">        <span class="keyword">try</span> container.encode(typeStr, forKey: .metatype)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> superEncoder = container.superEncoder(forKey: .object)</span><br><span class="line">        <span class="keyword">let</span> encodable = object <span class="keyword">as</span>? <span class="type">Encodable</span></span><br><span class="line">        <span class="keyword">try</span> encodable?.encode(to: superEncoder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，定义一个枚举，这个枚举需要遵守<code>Meta</code>协议，其中的case是Creature这个类簇的各个具体的类型：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CreatureMetaType</span>: <span class="title">String</span>, <span class="title">Meta</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> = <span class="type">Creature</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Raw Value需要与类名Type严格一致；case需要覆盖到类簇里的每一类型！</span></span><br><span class="line">    <span class="keyword">case</span> creature = <span class="string">"Creature"</span></span><br><span class="line">    <span class="keyword">case</span> animal = <span class="string">"Animal"</span></span><br><span class="line">    <span class="keyword">case</span> plant = <span class="string">"Plant"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">metatype</span><span class="params">(<span class="keyword">for</span> element: Creature)</span></span> -&gt; <span class="type">CreatureMetaType</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> element.metatype</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> type: <span class="type">Decodable</span>.<span class="type">Type</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .creature:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Creature</span>.<span class="keyword">self</span></span><br><span class="line">        <span class="keyword">case</span> .animal:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Animal</span>.<span class="keyword">self</span></span><br><span class="line">        <span class="keyword">case</span> .plant:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Plant</span>.<span class="keyword">self</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，对一个动态类型编解码时，需要这样写：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> creature: <span class="type">Creature</span> = <span class="type">Animal</span>(name: <span class="string">"miaomiao"</span>, age: <span class="number">2</span>, hasLeg: <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// Encode时，Encode的不是creature对象本身，而是装着creature对象的Wrapper: MetaObject&lt;CreatureMetaType&gt;</span></span><br><span class="line"><span class="keyword">let</span> creatureJsonData = <span class="keyword">try</span> <span class="type">JSONEncoder</span>().encode(<span class="type">MetaObject</span>&lt;<span class="type">CreatureMetaType</span>&gt;(creature))</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> str = <span class="type">String</span>(data: creatureJsonData, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(str)</span><br><span class="line">    <span class="comment">// 可以看到，creature对象实际的类型"Animal"被编码进json了</span></span><br><span class="line">    <span class="comment">// &#123;"metatype":"Animal","object":&#123;"super":&#123;"name":"miaomiao","age":2&#125;,"hasLeg":true&#125;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解码时，也是先解码出Wrapper</span></span><br><span class="line"><span class="keyword">let</span> decodedMetaObject: <span class="type">MetaObject</span>&lt;<span class="type">CreatureMetaType</span>&gt; = <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode(<span class="type">MetaObject</span>&lt;<span class="type">CreatureMetaType</span>&gt;.<span class="keyword">self</span>, from: creatureJsonData)</span><br><span class="line"><span class="comment">// 然后再取出其中Object，这个Object的类型是"Animal"</span></span><br><span class="line"><span class="keyword">let</span> decodedCreature = decodedMetaObject.object</span><br></pre></td></tr></table></figure>
<p>以上就是通过借助Wrapper对象MetaObject来编解码一个类簇的instance的方法（抱歉这句话好拗口）。  </p>
<p>接下来，我们要编码一个数组creatures，类型是[Creature]。其中实际装的是Animal、Plant或Creature本身。  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> creatures: [<span class="type">Creature</span>] = [</span><br><span class="line">    <span class="type">Animal</span>(name: <span class="string">"miaomiao"</span>, age: <span class="number">2</span>, hasLeg: <span class="literal">true</span>),</span><br><span class="line">    <span class="type">Plant</span>(name: <span class="string">"tree"</span>, age: <span class="number">463</span>, height: <span class="number">32.1</span>),</span><br><span class="line">    <span class="type">Creature</span>(name: <span class="string">"WangWang"</span>, age: <span class="number">2</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>类似于编码单个对象，我们同样是定义一个Wrapper，这个Wrapper里面装的是array：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MetaArray</span>&lt;<span class="title">M</span>: <span class="title">Meta</span>&gt;: <span class="title">Codable</span>, <span class="title">ExpressibleByArrayLiteral</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> array: [<span class="type">M</span>.<span class="type">Element</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> array: [<span class="type">M</span>.<span class="type">Element</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.array = array</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(arrayLiteral elements: <span class="type">M</span>.<span class="type">Element</span>...) &#123;</span><br><span class="line">        <span class="keyword">self</span>.array = elements</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> metatype</span><br><span class="line">        <span class="keyword">case</span> object</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> container = <span class="keyword">try</span> decoder.unkeyedContainer()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> elements: [<span class="type">M</span>.<span class="type">Element</span>] = []</span><br><span class="line">        <span class="keyword">while</span> !container.isAtEnd &#123;</span><br><span class="line">            <span class="keyword">let</span> nested = <span class="keyword">try</span> container.nestedContainer(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">            <span class="keyword">let</span> typeStr = <span class="keyword">try</span> nested.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .metatype)</span><br><span class="line">            <span class="keyword">let</span> metatype = <span class="type">M</span>.metatype(<span class="keyword">for</span>: typeStr)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> superDecoder = <span class="keyword">try</span> nested.superDecoder(forKey: .object)</span><br><span class="line">            <span class="keyword">let</span> object = <span class="keyword">try</span> metatype.type.<span class="keyword">init</span>(from: superDecoder)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> element = object <span class="keyword">as</span>? <span class="type">M</span>.<span class="type">Element</span> &#123;</span><br><span class="line">                elements.append(element)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        array = elements</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> container = encoder.unkeyedContainer()</span><br><span class="line">        <span class="keyword">try</span> array.forEach &#123; object <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> typeStr = <span class="type">String</span>(describing: type(of: object))</span><br><span class="line">            <span class="keyword">var</span> nested = container.nestedContainer(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">            <span class="keyword">try</span> nested.encode(typeStr, forKey: .metatype)</span><br><span class="line">            <span class="keyword">let</span> superEncoder = nested.superEncoder(forKey: .object)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> encodable = object <span class="keyword">as</span>? <span class="type">Encodable</span></span><br><span class="line">            <span class="keyword">try</span> encodable?.encode(to: superEncoder)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后借助这个Wrapper来对多态特性的Array进行编解码：  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> creaturesJsonData = <span class="keyword">try</span> <span class="type">JSONEncoder</span>().encode(<span class="type">MetaArray</span>&lt;<span class="type">CreatureMetaType</span>&gt;(creatures))</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> str = <span class="type">String</span>(data: creaturesJsonData, encoding: .utf8) &#123;</span><br><span class="line">    <span class="built_in">print</span>(str)</span><br><span class="line">    <span class="comment">// [&#123;"metatype":"Animal","object":&#123;"super":&#123;"name":"miaomiao","age":2&#125;,"hasLeg":true&#125;&#125;,&#123;"metatype":"Plant","object":&#123;"super":&#123;"name":"tree","age":463&#125;,"height":32.100000000000001&#125;&#125;,&#123;"metatype":"Creature","object":&#123;"name":"WangWang","age":2&#125;&#125;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> decodedMetaArray: <span class="type">MetaArray</span>&lt;<span class="type">CreatureMetaType</span>&gt; = <span class="keyword">try</span> <span class="type">JSONDecoder</span>().decode(<span class="type">MetaArray</span>&lt;<span class="type">CreatureMetaType</span>&gt;.<span class="keyword">self</span>, from: creaturesJsonData)</span><br><span class="line"><span class="keyword">let</span> decodedCreatures = decodedMetaArray.array</span><br></pre></td></tr></table></figure>
<p>全部代码请<a href="https://gist.github.com/anthann/a638ca1cd7f82f5bdfa48a6560cf7900" target="_blank" rel="noopener">点击这里</a>。代码使用Swift4.2编写，在XCode 10.1的Playground里测试有效。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文首先介绍了Swift 4里的<code>Codable</code>协议是什么，然后介绍了<code>Codable</code>的常规使用姿势，最后挖了一个“多态”的坑并且填了这个坑。<br><code>Codable</code>协议使得我们可以方便的把类型在二进制、Plist、JSON等格式之间编解码，而无需借助第三方库。开发朋友可以尝试学习并实践这个协议，相信可以一定程度上提高开发效率。</p>
<p>引用:<br><a href="https://stackoverflow.com/questions/44441223/encode-decode-array-of-types-conforming-to-protocol-with-jsonencoder" target="_blank" rel="noopener">Encode/Decode Array of Types conforming to protocol with JSONEncoder</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 anthann
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>